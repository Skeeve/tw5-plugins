{
    "title": "$:/plugins/skeeve/pick",
    "description": "pick out text by using regular expressions",
    "author": "Skeeve",
    "version": "1.0.1",
    "core-version": ">=5.1.3",
    "plugin-type": "plugin",
    "list": "readme license",
    "dependent": "$/plugins/skeeve/documentation",
    "dependents": "",
    "type": "application/json",
    "text": "{\n    \"tiddlers\": {\n        \"$:/plugins/skeeve/pick/icon\": {\n            \"title\": \"$:/plugins/skeeve/pick/icon\",\n            \"created\": \"20180222184551000\",\n            \"modified\": \"20180225125733000\",\n            \"text\": \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"22pt\\\" height=\\\"22pt\\\" viewBox=\\\"0 0 43.536 50.271\\\"><path fill=\\\"#ccc\\\" d=\\\"M21.768 0l21.768 12.568v25.135L21.768 50.271 0 37.703V12.568z\\\"/><path fill=\\\"#de87cd\\\" d=\\\"M17.8 3.969h7.937v13.229h-7.938zM9.862 17.198H17.8V41.01H9.862zm15.875 0h7.938V41.01h-7.938zM1.924 25.136h7.938v7.937H1.924z\\\"/><path fill=\\\"#de87cd\\\" d=\\\"M17.799 25.135h7.938v7.938h-7.938zm15.875 0h7.938v7.938h-7.938z\\\"/></svg>\\n\"\n        },\n        \"$:/plugins/skeeve/pick/license\": {\n            \"title\": \"$:/plugins/skeeve/pick/license\",\n            \"created\": \"20180225125733000\",\n            \"modified\": \"20180225140135000\",\n            \"text\": \"The pick plugin is published under the same [[permissive BSD 3-Clause License|https://opensource.org/licenses/BSD-3-Clause]] as [[TiddlyWiki|https://tiddlywiki.com]] stored in the shadow tiddler [[$:/core/copyright.txt]]:\\n\\n<div style=\\\"font-size: 0.5em;line-height:1.4;\\\">\\n\\n{{$:/core/copyright.txt}}\\n\\n</div>\\n\"\n        },\n        \"$:/plugins/skeeve/pick/pick.js\": {\n            \"title\": \"$:/plugins/skeeve/pick/pick.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/skeeve/pick/pick.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nFilter operator for regexp matching and picking out capturing groups\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*\\nExport our filter function\\n*/\\nvar regexper = function(source,operator,options, grouping) {\\n\\tvar results = [],\\n\\t\\tfieldname = (operator.suffix || \\\"title\\\").toLowerCase(),\\n\\t\\tregexpString, regexp, flags = \\\"\\\", match,\\n\\t\\tgetFieldString = function(tiddler,title) {\\n\\t\\t\\tif(tiddler) {\\n\\t\\t\\t\\treturn tiddler.getFieldString(fieldname);\\n\\t\\t\\t} else if(fieldname === \\\"title\\\") {\\n\\t\\t\\t\\treturn title;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t// Process flags and construct regexp\\n\\tregexpString = operator.operand;\\n\\tmatch = /^\\\\(\\\\?([gim]+)\\\\)/.exec(regexpString);\\n\\tif(match) {\\n\\t\\tflags = match[1];\\n\\t\\tregexpString = regexpString.substr(match[0].length);\\n\\t} else {\\n\\t\\tmatch = /\\\\(\\\\?([gim]+)\\\\)$/.exec(regexpString);\\n\\t\\tif(match) {\\n\\t\\t\\tflags = match[1];\\n\\t\\t\\tregexpString = regexpString.substr(0,regexpString.length - match[0].length);\\n\\t\\t}\\n\\t}\\n\\tvar global= flags.indexOf('g') > -1;\\n\\ttry {\\n\\t\\tregexp = new RegExp(regexpString,flags);\\n\\t} catch(e) {\\n\\t\\treturn [\\\"\\\" + e];\\n\\t}\\n\\t// Process the incoming tiddlers\\n\\tif(operator.prefix === \\\"!\\\") {\\n\\t\\t// If negated, we handle it like the regexp filter\\n\\t\\tsource(function(tiddler,title) {\\n\\t\\t\\tvar text = getFieldString(tiddler,title);\\n\\t\\t\\tif(text !== null) {\\n\\t\\t\\t\\tif(!regexp.exec(text)) {\\n\\t\\t\\t\\t\\tresults.push(title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} else {\\n\\t\\tsource(function(tiddler,title) {\\n\\t\\t\\tvar text = getFieldString(tiddler,title);\\n\\t\\t\\tif(text !== null) {\\n\\t\\t\\t\\tvar m;\\n\\t\\t\\t\\twhile (m = regexp.exec(text)) {\\n\\t\\t\\t\\t\\t// Just 1 match means: We had no capturing group\\n\\t\\t\\t\\t\\t// act like regexp filter\\n\\t\\t\\t\\t\\tif (m.length == 1) {\\n\\t\\t\\t\\t\\t\\tresults.push(title);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrouping(m, results);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\treturn results;\\n};\\nexports.pick = function(source,operator,options) {\\n\\tregexper(source,operator,options,function(m, results){\\n\\t\\t// push each group as a result\\n\\t\\tfor (var i=1; i<m.length;++i) {\\n\\t\\t\\tresults.push(m[i]);\\n\\t\\t}\\n\\t});\\n};\\nexports.pickgroups = function(source,operator,options) {\\n\\tregexper(source,operator,options,function(m, results){\\n\\t\\t// Join all capturing groups with a NUL character\\n\\t\\tresults.push(m.slice(1).join(\\\"\\\\0\\\"));\\n\\t});\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"filteroperator\"\n        },\n        \"$:/plugins/skeeve/pick/readme\": {\n            \"title\": \"$:/plugins/skeeve/pick/readme\",\n            \"created\": \"20180225125733000\",\n            \"modified\": \"20180225152532000\",\n            \"text\": \"A set of filters and widgets to pick out texts by using regular expressions.\\n\\nFor more information, please see the online documentation.\\n\\n{{Online Documentation#pick Plugin||$:/plugins/skeeve/documentation/documentation}}\\n\"\n        },\n        \"$:/plugins/skeeve/pick/splitgroups.js\": {\n            \"title\": \"$:/plugins/skeeve/pick/splitgroups.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/skeeve/pick/splitgroups.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nSet variables to group values widget\\n\\n```\\n<$splitgroups name1=… name2=…>\\n    :\\n</$splitgroups>\\n```\\n\\nExample:\\n\\n```\\n<$splitgroups a=\\\"$1\\\" b=\\\"test $2\\\" c=\\\"$$ $3\\\" d=\\\"$1 $4\\\">\\n    …anything using above variables…\\n</$splitgroups>\\n```\\n# a will get the first group\\n# b will be set to \\\"test\\\" followed by the second group\\n# c will be set to a literal \\\"$\\\" followed by the third group\\n# d will be set to group 1 followed by group 4\\n\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nvar SplitgroupsWidget = function(parseTreeNode,options) {\\n\\tthis.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nSplitgroupsWidget.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nSplitgroupsWidget.prototype.render = function(parent,nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent,nextSibling);\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nSplitgroupsWidget.prototype.execute = function() {\\n\\t// Get our parameters\\n\\t// As there is nothing which will give me the attributes,\\n\\t// I have to access the object myself…\\n\\tvar separator= this.getAttribute(\\\"$separator\\\",\\\"\\\\0\\\");\\n\\tvar groups= this.getVariable(\\\"currentTiddler\\\").split(separator);\\n\\tfor(var name in this.attributes) {\\n\\t\\tif( name.charAt(0) === \\\"$\\\") {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// Split so that every odd match is a group index or a \\\"$\\\"\\n\\t\\tvar shattered= this.attributes[name].split(/\\\\$(\\\\d+|\\\\$)/g);\\n\\t\\tvar value= shattered[0];\\n\\t\\tfor (var i= 1; i<shattered.length; ++i) {\\n\\t\\t\\t// if we have an even match\\n\\t\\t\\t// or the last match (an even one) ended with \\\"$\\\"\\n\\t\\t\\t// or this one is \\\"$\\\", we simply append this one\\n\\t\\t\\tif ( i%2 == 0 || shattered[i-1].substr(-1) == \\\"$\\\" || shattered[i] == \\\"$\\\") {\\n\\t\\t\\t\\tvalue+= shattered[i];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t// get the groups index as a number\\n\\t\\t\\tvar j=shattered[i]-1;\\n\\t\\t\\t// if it is an existing number, we append the group\\n\\t\\t\\tif (  j>=0 && j < groups.length ) {\\n\\t\\t\\t\\tvalue+= groups[j];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t// Otherwise we append the literal $ followed by the index\\n\\t\\t\\tvalue+= \\\"$\\\" + shattered[i];\\n\\t\\t}\\n\\t\\tthis.setVariable(name, value, this.parseTreeNode.params);\\n\\t}\\n\\t// Construct the child widgets\\n\\tthis.makeChildWidgets();\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nSplitgroupsWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tfor(var attr in changedAttributes) {\\n\\t\\tif(changedAttributes[attr]) {\\n\\t\\t\\tthis.refreshSelf();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nexports.splitgroups = SplitgroupsWidget;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        }\n    }\n}"
}